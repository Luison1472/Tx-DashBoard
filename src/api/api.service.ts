import { Injectable, Logger } from "@nestjs/common";
import { HttpService } from "@nestjs/axios";
import { ConfigService } from "@nestjs/config";
import { AxiosError } from "axios";
import { catchError, firstValueFrom } from "rxjs";
import * as crypto from 'crypto';
import axios from "axios";
import * as secp256k1 from "secp256k1"; //"secp256k1": "^5.0.0",
import { encode, RecordView } from "@planetarium/bencodex"; //"@planetarium/bencodex": "^0.2.2",
import { ethers } from "ethers"; //"ethers": "^5.5.1";
import {NodeHealthService} from "./db/node-health/node-health.service";
import * as https from "node:https";
import * as http from "node:http";


@Injectable()
export class ApiService {
    private endPointListURL = "https://planets.nine-chronicles.com/planets/";
    private readonly logger = new Logger(ApiService.name);
    private accounts;
    private instanceForSend;
    private instanceForCheck;

    constructor(
        private readonly httpService: HttpService,
        private readonly configService: ConfigService,
        private readonly nodeHealthService: NodeHealthService
    ) {
        this.instanceForSend = axios.create({
            httpAgent: new http.Agent({ keepAlive: true }),
            httpsAgent: new https.Agent({ keepAlive: true }),
            timeout: 20000,  // ‚úÖ timeout Ï¶ùÍ∞Ä (Í∏∞Ï°¥ 5000ms ‚Üí 20000ms)
        });

        this.instanceForCheck = axios.create({
            httpAgent: new http.Agent({ keepAlive: true }),
            httpsAgent: new https.Agent({ keepAlive: true }),
            timeout: 25000,  // ‚úÖ timeout Ï¶ùÍ∞Ä (Í∏∞Ï°¥ 20000ms ‚Üí 25000ms)
        });
        this.accounts = [
            {
                privateKey: this.configService.get<string>('PRIVATE_KEY_0'),
                address: this.configService.get<string>('ACCOUNT_ADDRESS_0'),
            },
            {
                privateKey: this.configService.get<string>('PRIVATE_KEY_1'),
                address: this.configService.get<string>('ACCOUNT_ADDRESS_1'),
            },
            {
                privateKey: this.configService.get<string>('PRIVATE_KEY_2'),
                address: this.configService.get<string>('ACCOUNT_ADDRESS_2'),
            },
            {
                privateKey: this.configService.get<string>('PRIVATE_KEY_3'),
                address: this.configService.get<string>('ACCOUNT_ADDRESS_3'),
            },
            {
                privateKey: this.configService.get<string>('PRIVATE_KEY_4'),
                address: this.configService.get<string>('ACCOUNT_ADDRESS_4'),
            },
            {
                privateKey: this.configService.get<string>('PRIVATE_KEY_5'),
                address: this.configService.get<string>('ACCOUNT_ADDRESS_5'),
            },
            {
                privateKey: this.configService.get<string>('PRIVATE_KEY_6'),
                address: this.configService.get<string>('ACCOUNT_ADDRESS_6'),
            },
            {
                privateKey: this.configService.get<string>('PRIVATE_KEY_7'),
                address: this.configService.get<string>('ACCOUNT_ADDRESS_7'),
            },
            {
                privateKey: this.configService.get<string>('PRIVATE_KEY_8'),
                address: this.configService.get<string>('ACCOUNT_ADDRESS_8'),
            }
        ];
    }

    public async getRPCEndPoints() {
    console.log(`üöÄ getRPCEndPoints() Ïã§Ìñâ!`);
    
    try {
        const { data } = await firstValueFrom(
            this.httpService.get(this.endPointListURL).pipe(
                catchError((error: AxiosError) => {
                    console.log('‚ùå RPC ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏöîÏ≤≠ Ïã§Ìå®:', error.message);
                    throw new Error('RPC ÏóîÎìúÌè¨Ïù∏Ìä∏ Ï°∞Ìöå Ï§ë Ïò§Î•ò Î∞úÏÉù.');
                }),
            ),
        );

        if (!data || data.length < 2) {
            throw new Error('üö® RPC ÏóîÎìúÌè¨Ïù∏Ìä∏ Îç∞Ïù¥ÌÑ∞Í∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.');
        }

        console.log(`‚úÖ RPC ÏóîÎìúÌè¨Ïù∏Ìä∏ Í∞ÄÏ†∏Ïò¥!`, data);
        return [data[0].rpcEndpoints['headless.gql'], data[1].rpcEndpoints['headless.gql']];
    } catch (error) {
        console.error(`‚ùå getRPCEndPoints() Ïã§Ìñâ Ï§ë Ïò§Î•ò Î∞úÏÉù:`, error.message);
        throw error;
    }
}


    public async send(groupName: string, rpcEndpoints: string[], timeStamp: Date) {
    console.log(`üî• send() Ïã§ÌñâÎê®! groupName: ${groupName}, endpoints: ${rpcEndpoints.length}`);
    console.log('üõ†Ô∏è this.accounts ÌôïÏù∏:', this.accounts);

    const uniqueTxs = new Set();

    for (let i = 0; i < rpcEndpoints.length; i++) {
        if (i >= this.accounts.length) continue;

        const sender = this.accounts[i].address;
        const recipient = this.accounts[(i + 1) % this.accounts.length].address;

        if (uniqueTxs.has(`${sender}-${recipient}`)) {
            console.warn(`‚ö†Ô∏è Ï§ëÎ≥µ Î∞©ÏßÄ: Ïù¥ÎØ∏ Ïã§ÌñâÎêú Ìä∏ÎûúÏû≠ÏÖò! Sender: ${sender}, Recipient: ${recipient}`);
            continue;
        }

        uniqueTxs.add(`${sender}-${recipient}`);
        let action = groupName === 'odin'
            ? this.makeTransferInOdin(sender, recipient)
            : this.makeTransferInHeimdall(sender, recipient);

        try {
            const txHash = await this.sendTx(rpcEndpoints[i], action, this.accounts[i]);
            console.log(`‚úÖ Ìä∏ÎûúÏû≠ÏÖò ÏÑ±Í≥µ! Endpoint: ${rpcEndpoints[i]}, TxHash: ${txHash}`);

            await this.nodeHealthService.updateTempTx(rpcEndpoints[i], txHash, timeStamp);
            
            // ‚úÖ Ìä∏ÎûúÏû≠ÏÖò Í∞Ñ Ïã§Ìñâ Í∞ÑÍ≤©ÏùÑ Îë† (2Ï¥à ÎåÄÍ∏∞)
            await new Promise(resolve => setTimeout(resolve, 2000));

        } catch (error) {
            console.error(`‚ùå Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìå®! Endpoint: ${rpcEndpoints[i]}, Error:`, error.message);

            const failedTxHash = "FAILED_TX_HASH";  // üö® ÏûÑÏãú Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
            console.log("üßê updateFailedTempTx() Ïã§ÌñâÎê®. Ï†ÄÏû•Ìï† Îç∞Ïù¥ÌÑ∞:", {
                groupName,
                endpoint: rpcEndpoints[i],
                timestamp: timeStamp,
                txHash: failedTxHash,
            });

            await this.nodeHealthService.updateFailedTempTx(rpcEndpoints[i], failedTxHash, timeStamp);
            
            // ‚úÖ Ïò§Î•ò Î∞úÏÉù Ïãú 5Ï¥à ÎåÄÍ∏∞ ÌõÑ Îã§Ïùå Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìñâ (Ïû¨ÏãúÎèÑ Í∞ÑÍ≤© Ï∂îÍ∞Ä)
            await new Promise(resolve => setTimeout(resolve, 5000));
        }
    }
}

    public async saveTemp(groupName: string, rpcEndpoints: string[], timeStamp: Date) {
        for (let i = 0; i < rpcEndpoints.length; i++) {
            if(i >= this.accounts.length) //ÎßåÏïΩ ÏóîÎìúÌè¨Ïù∏Ìä∏Í∞Ä Ìõ®Ïî¨ Îçî ÎäòÏñ¥ÎÇ¨ÏùÑ Í≤ΩÏö∞ Í≥ÑÏ†ï ÏÉùÏÑ± Î∞îÎûå.
                break;
            await this.nodeHealthService.saveTempTx(groupName, rpcEndpoints[i], timeStamp);
        }
    }

    public async findAllLostMinute(groupedData: { [key: string]: any[] }) {
        const commonTimestamps = [];
        // groupedDataÏóêÏÑú Í∞Å URLÍ≥º Ìï¥Îãπ ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑÎ•º SetÏóê Ï†ÄÏû•
        for (const [endpoint_url, data] of Object.entries(groupedData)) {
            data.forEach(item => commonTimestamps.push({endpoint_url: endpoint_url, timestamp: new Date(item.timeStamp).toISOString()}));
        }
        console.log(commonTimestamps);
        return commonTimestamps;
    }


    public async groupingLostRequestDetail(groupedData: { [key: string]: any[] }) {
        const missingNodesByEndpoint: { [key: string]: any[] } = {};

        for (const [endpoint_url, data] of Object.entries(groupedData)) {
            const missingNodes: string[] = [];

            data.forEach(item => {
                const timestamp = item.timeStamp.toISOString();
                missingNodes.push(timestamp.split(':')[0] + ':' + timestamp.split(':')[1]);
            });
            if (missingNodes.length > 0) {
                missingNodesByEndpoint[endpoint_url] = missingNodes; // ÎàÑÎùΩÎêú ÎÖ∏ÎìúÎ•º Ï†ÄÏû•
            }
            else
                missingNodesByEndpoint[endpoint_url] = [];
        }
        return missingNodesByEndpoint;
    }

    private makeTransferInOdin(sender: string, recipient: string) {
        return Buffer.from(encode(new RecordView({
            type_id: 'transfer_asset5',
            values: {
                amount: [
                    new RecordView(
                        {
                            decimalPlaces: Buffer.from([0x02]),
                            minters: [this.hexToBuffer("0x47d082a115c63e7b58b1532d20e631538eafadde")],
                            ticker: "NCG",
                        },
                        "text"
                    ),
                    1n,
                ],
                recipient: this.hexToBuffer(recipient),
                sender: this.hexToBuffer(sender),
            }
        }, 'text'))).toString('hex');
    }

    private makeTransferInHeimdall(sender: string, recipient: string) {
        return Buffer.from(encode(new RecordView({
            type_id: 'transfer_asset5',
            values: {
                amount: [
                    new RecordView(
                        {
                            decimalPlaces: Buffer.from([0x02]),
                            minters: null,
                            ticker: "NCG",
                        },
                        "text"
                    ),
                    1n,
                ],
                recipient: this.hexToBuffer(recipient),
                sender: this.hexToBuffer(sender),
            }
        }, 'text'))).toString('hex');
    }

    hexToBuffer(hex: string): Buffer {
        return Buffer.from(
            ethers.utils.arrayify(hex, { allowMissingPrefix: true })
        );
    }

    pad32(msg: Buffer): Buffer {
        let buf: Buffer;
        if (msg.length < 32) {
            buf = Buffer.alloc(32);
            buf.fill(0);
            msg.copy(buf, 32 - msg.length);
            return buf;
        } else {
            return msg;
        }
    }

     async sendTx(endpoint: string, action: string, account): Promise<string | undefined> {
    const wallet = new ethers.Wallet(account.privateKey);
    
    // ‚úÖ Nonce Í∞í Ï§ëÎ≥µ Î∞©ÏßÄ (Í∞ïÏ†ú Ï¶ùÍ∞Ä)
    let nonce = await this.nextTxNonce(endpoint, account.address);
    console.log(`üî¢ ÏÇ¨Ïö©Îêú Nonce Í∞í: ${nonce} (Account: ${account.address})`);

    const _unsignedTx = await this.unsignedTx(endpoint, wallet.publicKey.slice(2), action, nonce);
    
    const unsignedTxId = crypto.createHash('sha256').update(_unsignedTx, 'hex').digest();
    const { signature } = secp256k1.ecdsaSign(this.pad32(unsignedTxId), this.hexToBuffer(wallet.privateKey));

    const sign = Buffer.from(secp256k1.signatureExport(signature));
    const { data: { transaction: { signTransaction: signTx } } } = await this.signTransaction(endpoint, _unsignedTx, sign.toString('hex'));

    const { txId } = await this.stageTx(endpoint, signTx);
    console.log(`‚úÖ Ìä∏ÎûúÏû≠ÏÖò ÏÑ±Í≥µ: ${txId}`);
    
    return txId;
}


     async nextTxNonce(endpoint: string, address: string): Promise<number> {
        const {data} = await this.instanceForSend.post(endpoint, {
            variables: {address},
            query: `
              query getNextTxNonce($address: Address!){
                transaction{
                    nextTxNonce(address: $address)
                }
              }
            `})
        return data["data"]["transaction"]["nextTxNonce"];
    }


    async unsignedTx(endpoint: string, publicKey: string, plainValue: string, nonce: number): Promise<string> {
        const maxGasPrice: FungibleAssetValue = {
            quantity: 20,
            ticker: 'Mead',
            decimalPlaces: 18
        };

        const { data } = await this.instanceForSend.post(endpoint, {
            variables: { publicKey, plainValue, nonce, maxGasPrice },
            query: `
                query unsignedTx($publicKey: String!, $plainValue: String!, $nonce: Long, $maxGasPrice: FungibleAssetValueInputType) {
                  transaction {
                    unsignedTransaction(publicKey: $publicKey, plainValue: $plainValue nonce: $nonce, maxGasPrice: $maxGasPrice)
                  }
                }
              `})
        return data["data"]["transaction"]["unsignedTransaction"];
    }

     async signTransaction(endpoint: string, unsignedTx: string, base64Sign: string): Promise<any> {
        const { data } = await this.instanceForSend.post(endpoint, {
            "variables": { unsignedTx, signature: base64Sign },
            "query": `
                  query attachSignature($unsignedTx: String!, $signature: String!) {
                    transaction {
                      signTransaction(unsignedTransaction: $unsignedTx, signature: $signature)
                    }
                  }
                `
        })
        return data;
    }

    async stageTx(endpoint: string, payload: string): Promise<{ txId: string }> {
        const { data } = await this.instanceForSend.post(endpoint, {
            variables: {payload},
            query: `
            mutation transfer($payload: String!) {
              stageTransaction(payload: $payload)
            }
          `
        })
        try {
            return {txId: data["data"]["stageTransaction"]};
        } catch (e) {
            console.log(e, data);
            throw e;
        }
    }

    async getTxStatus(endpoint: string, txIds: string[]) {
    const { data } = await this.instanceForCheck.post(endpoint, {
        variables: { txIds },  // ‚úÖ GraphQL Î≥ÄÏàòÎ•º ÏÇ¨Ïö©ÌïòÏó¨ ÏïàÏ†ÑÌïòÍ≤å Ï†ÑÎã¨
        query: `
        query getTx($txIds: [String!]!) {
            transaction {
                transactionResults(txIds: $txIds) {
                    txStatus
                    exceptionNames
                }
            }
        }
        `
    });

    return data?.data?.transaction?.transactionResults || [];  // ÏùëÎãµ Í≤ÄÏ¶ù Ï∂îÍ∞Ä
}



    async resolvePendingTransactions() {
        const pendingTransactions: Array<{ id: number, endpoint_url: string, txHash: string }> = await this.nodeHealthService.getPendingTransactions(); // Î™ÖÏãúÏ†Å ÌÉÄÏûÖ

        // endpoint_url Í∏∞Ï§ÄÏúºÎ°ú Í∑∏Î£πÌôî
        const groupedTransactions = pendingTransactions.reduce<{ [key: string]: Array<{ id: number, endpoint_url: string, txHash: string }> }>((acc, row) => {
            if (!acc[row.endpoint_url]) {
                acc[row.endpoint_url] = [];
            }
            acc[row.endpoint_url].push(row);
            return acc;
        }, {});

        let checkEndpointUrl;
        // Í∞Å endpoint_url Í∑∏Î£πÎ≥ÑÎ°ú ÏÉÅÌÉú Ï°∞Ìöå Î∞è Ï≤òÎ¶¨
        for (const [endpoint_url, transactions] of Object.entries(groupedTransactions)) {
            const txIds = transactions.map(tx => tx.txHash); // Ìï¥Îãπ endpoint_urlÏóê Ìï¥ÎãπÌïòÎäî txHash Î∞∞Ïó¥

            if(endpoint_url.includes("heimdall"))
                checkEndpointUrl = "https://heimdall-rpc-1.nine-chronicles.com/graphql";
            else
                checkEndpointUrl = "https://odin-rpc-2.nine-chronicles.com/graphql";

            const statuses = await this.getTxStatus(checkEndpointUrl, txIds);
            // 5. ÏÉÅÌÉúÎ≥ÑÎ°ú Ï≤òÎ¶¨
            for (const [index, status] of statuses.entries()) {
    const row = transactions[index]; // Í∞Å ÏÉÅÌÉúÏóê ÎåÄÏùëÌïòÎäî Ìä∏ÎûúÏû≠ÏÖò Ï†ïÎ≥¥

    if (!status || !status.txStatus) {
        console.error(`‚ùå Ìä∏ÎûúÏû≠ÏÖò ÏÉÅÌÉúÎ•º ÌôïÏù∏Ìï† Ïàò ÏóÜÏùå. (ID: ${row.id}, TxHash: ${row.txHash})`);
        continue;
    }

                switch (status.txStatus) {
                    case 'SUCCESS':
                        console.log(`‚úÖ Ìä∏ÎûúÏû≠ÏÖò ÏÑ±Í≥µ! TxHash: ${row.txHash}`);
                        await this.nodeHealthService.updateCompletedTx(row.id);
                        break;

                    case 'STAGING':
                    case 'PENDING':
                        console.log(`‚è≥ Ìä∏ÎûúÏû≠ÏÖò ÎåÄÍ∏∞ Ï§ë (ID: ${row.id}, TxHash: ${row.txHash})`);
                        await this.nodeHealthService.updateStagingTxBatch([row.id]);
                        break;

                    case 'FAILED':
                    case 'INVALID':
                        const errorMessage = status.exceptionNames?.join(', ') || 'Ïïå Ïàò ÏóÜÏùå'; // ÏòàÏô∏ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
                        console.error(`‚ùå Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìå®! TxHash: ${row.txHash}, Ïù¥Ïú†: ${errorMessage}`);
                        await this.nodeHealthService.updateFailedTx([row.id], [errorMessage]);
                        break;

                    default:
                        console.warn(`‚ö†Ô∏è ÏòàÏÉÅÏπò Î™ªÌïú Ìä∏ÎûúÏû≠ÏÖò ÏÉÅÌÉú: ${status.txStatus} (ID: ${row.id}, TxHash: ${row.txHash})`);
                        break;
                }
            }
        }
    }



}

interface FungibleAssetValue {
    quantity: number;
    ticker: string;
    decimalPlaces: number;
}